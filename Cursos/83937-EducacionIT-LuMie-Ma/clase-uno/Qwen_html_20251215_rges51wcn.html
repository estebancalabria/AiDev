<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Flappy Bird</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
      background: #333;
    }
    canvas {
      border: 2px solid #000;
      background: #70c5ce;
    }
  </style>
</head>
<body>
<canvas id="game" width="320" height="480"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Bird
const bird = {
  x: 50,
  y: canvas.height / 2 - 10,
  radius: 10,
  gravity: 0.5,
  velocity: 0,
  jump: -8,
  draw() {
    ctx.fillStyle = '#FFD700';
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
  },
  update() {
    this.velocity += this.gravity;
    this.y += this.velocity;
    if (this.y + this.radius > canvas.height) {
      this.y = canvas.height - this.radius;
      gameOver();
    }
    if (this.y - this.radius < 0) {
      this.y = this.radius;
      this.velocity = 0;
    }
  },
  flap() {
    this.velocity = this.jump;
  }
};

// Pipes
const pipes = {
  position: [],
  gap: 120,
  maxY: 200,
  width: 50,
  speed: 2,
  spawnFrame: 0,
  spawnInterval: 90, // frames

  update() {
    if (frames % this.spawnInterval === 0) {
      const topHeight = Math.random() * this.maxY + 20;
      this.position.push({
        x: canvas.width,
        topHeight: topHeight,
        bottomY: topHeight + this.gap,
        passed: false
      });
    }

    for (let i = 0; i < this.position.length; i++) {
      const pipe = this.position[i];
      pipe.x -= this.speed;

      // Collision
      if (
        bird.x + bird.radius > pipe.x &&
        bird.x - bird.radius < pipe.x + this.width &&
        (bird.y - bird.radius < pipe.topHeight ||
         bird.y + bird.radius > pipe.bottomY)
      ) {
        gameOver();
      }

      // Score
      if (!pipe.passed && pipe.x + this.width < bird.x) {
        pipe.passed = true;
        score++;
      }

      // Remove off-screen pipes
      if (pipe.x + this.width < 0) {
        this.position.splice(i, 1);
        i--;
      }
    }
  },

  draw() {
    ctx.fillStyle = '#228B22';
    for (const pipe of this.position) {
      // Top pipe
      ctx.fillRect(pipe.x, 0, this.width, pipe.topHeight);
      // Bottom pipe
      ctx.fillRect(pipe.x, pipe.bottomY, this.width, canvas.height - pipe.bottomY);
    }
  }
};

let frames = 0;
let score = 0;
let gameRunning = true;

function drawScore() {
  ctx.fillStyle = '#fff';
  ctx.font = '24px Arial';
  ctx.fillText(score.toString(), canvas.width / 2 - 10, 40);
}

function gameOver() {
  gameRunning = false;
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#fff';
  ctx.font = '30px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);
  ctx.font = '20px Arial';
  ctx.fillText('Clic para reiniciar', canvas.width / 2, canvas.height / 2 + 40);
}

function resetGame() {
  bird.y = canvas.height / 2 - 10;
  bird.velocity = 0;
  pipes.position = [];
  score = 0;
  frames = 0;
  gameRunning = true;
}

function loop() {
  ctx.fillStyle = '#70c5ce';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (gameRunning) {
    bird.update();
    pipes.update();
    frames++;
  }

  bird.draw();
  pipes.draw();
  drawScore();

  requestAnimationFrame(loop);
}

canvas.addEventListener('click', () => {
  if (gameRunning) {
    bird.flap();
  } else {
    resetGame();
  }
});

document.addEventListener('keydown', (e) => {
  if (e.code === 'Space') {
    if (gameRunning) bird.flap();
    else resetGame();
  }
});

loop();
</script>
</body>
</html>